# symbols = ['BTCUSDT', 'ETHUSDT', 'BCHUSDT', 'XRPUSDT', 'LTCUSDT', 'TRXUSDT', 'ETCUSDT', 'LINKUSDT', 'XLMUSDT', 'ADAUSDT', 'DASHUSDT', 'ZECUSDT', 'XTZUSDT', 'BNBUSDT', 'ATOMUSDT', 'ONTUSDT', 'IOTAUSDT', 'BATUSDT', 'VETUSDT', 'NEOUSDT', 'QTUMUSDT', 'IOSTUSDT', 'THETAUSDT', 'ALGOUSDT', 'ZILUSDT', 'KNCUSDT', 'ZRXUSDT', 'COMPUSDT', 'OMGUSDT', 'DOGEUSDT', 'SXPUSDT', 'KAVAUSDT', 'BANDUSDT', 'RLCUSDT', 'MKRUSDT', 'SNXUSDT', 'DOTUSDT', 'DEFIUSDT', 'YFIUSDT', 'BALUSDT', 'CRVUSDT', 'TRBUSDT', 'RUNEUSDT', 'SUSHIUSDT', 'EGLDUSDT', 'SOLUSDT', 'ICXUSDT', 'STORJUSDT', 'UNIUSDT', 'AVAXUSDT', 'ENJUSDT', 'FLMUSDT', 'KSMUSDT', 'NEARUSDT', 'AAVEUSDT', 'FILUSDT', 'RSRUSDT', 'LRCUSDT', 'BELUSDT', 'AXSUSDT', 'ALPHAUSDT', 'ZENUSDT', 'SKLUSDT', 'GRTUSDT', 'BNTUSDT', '1INCHUSDT', 'CHZUSDT', 'SANDUSDT', 'ANKRUSDT', 'LITUSDT', 'RVNUSDT', 'SFPUSDT', 'XEMUSDT', 'COTIUSDT', 'CHRUSDT', 'MANAUSDT', 'ALICEUSDT', 'HBARUSDT', 'ONEUSDT', 'LINAUSDT', 'STMXUSDT', 'DENTUSDT', 'CELRUSDT', 'HOTUSDT', 'MTLUSDT', 'OGNUSDT', 'NKNUSDT', '1000SHIBUSDT', 'BAKEUSDT', 'GTCUSDT', 'BTCDOMUSDT', 'MASKUSDT', 'IOTXUSDT', 'C98USDT', 'ATAUSDT', 'DYDXUSDT', '1000XECUSDT', 'GALAUSDT', 'CELOUSDT', 'ARUSDT', 'ARPAUSDT', 'CTSIUSDT', 'LPTUSDT', 'ENSUSDT', 'PEOPLEUSDT', 'ROSEUSDT', 'DUSKUSDT', 'FLOWUSDT', 'IMXUSDT', 'API3USDT', 'GMTUSDT', 'APEUSDT', 'WOOUSDT', 'JASMYUSDT', 'OPUSDT', 'XMRUSDT', 'INJUSDT', 'STGUSDT', 'SPELLUSDT', '1000LUNCUSDT', 'LUNA2USDT', 'LDOUSDT', 'APTUSDT', 'QNTUSDT', 'FXSUSDT', 'HOOKUSDT', 'MAGICUSDT', 'TUSDT', 'HIGHUSDT', 'MINAUSDT', 'ASTRUSDT', 'PHBUSDT', 'FETUSDT', 'GMXUSDT', 'CFXUSDT', 'STXUSDT', 'ACHUSDT', 'SSVUSDT', 'CKBUSDT', 'PERPUSDT', 'LQTYUSDT', 'ARBUSDT', 'IDUSDT', 'JOEUSDT', 'LEVERUSDT', 'TRUUSDT', 'RDNTUSDT', 'HFTUSDT', 'XVSUSDT', 'BLURUSDT', 'EDUUSDT', '1000PEPEUSDT', '1000FLOKIUSDT', 'UMAUSDT', 'COMBOUSDT', 'SUIUSDT', 'NMRUSDT', 'MAVUSDT', 'XVGUSDT', 'WLDUSDT', 'PENDLEUSDT', 'ARKMUSDT', 'AGLDUSDT', 'YGGUSDT', 'DODOXUSDT', 'OXTUSDT', 'SEIUSDT', 'CYBERUSDT', 'HIFIUSDT', 'ARKUSDT', 'BICOUSDT', 'LOOMUSDT', 'BIGTIMEUSDT', 'BONDUSDT', 'ORBSUSDT', 'WAXPUSDT', 'BSVUSDT', 'RIFUSDT', 'POLYXUSDT', 'GASUSDT', 'POWRUSDT', 'TIAUSDT', 'CAKEUSDT', 'MEMEUSDT', 'TOKENUSDT', 'ORDIUSDT', 'STEEMUSDT', 'ILVUSDT', 'NTRNUSDT', 'KASUSDT', 'BEAMXUSDT', '1000BONKUSDT', 'PYTHUSDT', 'SUPERUSDT', 'USTCUSDT', 'ONGUSDT', 'ETHWUSDT', 'JTOUSDT', '1000SATSUSDT', 'AUCTIONUSDT', '1000RATSUSDT', 'ACEUSDT', 'MOVRUSDT', 'TWTUSDT', 'NFPUSDT', 'AIUSDT', 'XAIUSDT', 'WIFUSDT', 'MANTAUSDT', 'ONDOUSDT', 'LSKUSDT', 'ALTUSDT', 'JUPUSDT', 'ZETAUSDT', 'RONINUSDT', 'DYMUSDT', 'OMUSDT', 'PIXELUSDT', 'STRKUSDT', 'GLMUSDT', 'PORTALUSDT', 'TONUSDT', 'AXLUSDT', 'MYROUSDT', 'METISUSDT', 'AEVOUSDT', 'VANRYUSDT', 'BOMEUSDT', 'ETHFIUSDT', 'ENAUSDT', 'WUSDT', 'TNSRUSDT', 'SAGAUSDT', 'TAOUSDT', 'OMNIUSDT', 'REZUSDT', 'BBUSDT', 'NOTUSDT', 'TURBOUSDT', 'IOUSDT', 'ZKUSDT', 'MEWUSDT', 'LISTAUSDT', 'ZROUSDT', 'RENDERUSDT', 'BANANAUSDT', 'RAREUSDT', 'GUSDT', 'SYNUSDT', 'SYSUSDT', 'VOXELUSDT', 'BRETTUSDT', 'ALPACAUSDT', 'POPCATUSDT', 'SUNUSDT', 'VIDTUSDT', 'NULSUSDT', 'DOGSUSDT', 'MBOXUSDT', 'CHESSUSDT', 'FLUXUSDT', 'BSWUSDT', 'QUICKUSDT', 'NEIROETHUSDT', 'RPLUSDT', 'POLUSDT', 'UXLINKUSDT', 'NEIROUSDT', '1MBABYDOGEUSDT', 'KDAUSDT', 'FIDAUSDT', 'FIOUSDT', 'CATIUSDT', 'GHSTUSDT', 'LOKAUSDT', 'HMSTRUSDT', 'REIUSDT', 'COSUSDT', 'EIGENUSDT', 'DIAUSDT', '1000CATUSDT', 'SCRUSDT', 'GOATUSDT', 'MOODENGUSDT', 'SAFEUSDT', 'SANTOSUSDT', 'TROYUSDT', 'PONKEUSDT', 'CETUSUSDT', 'COWUSDT', '1000000MOGUSDT', 'GRASSUSDT', 'DRIFTUSDT', 'SWELLUSDT', 'PNUTUSDT', 'ACTUSDT', 'HIPPOUSDT', '1000XUSDT', 'DEGENUSDT', 'BANUSDT', 'AKTUSDT', 'SLERFUSDT', 'SCRTUSDT', '1000WHYUSDT', '1000CHEEMSUSDT', 'THEUSDT', 'MORPHOUSDT', 'CHILLGUYUSDT', 'KAIAUSDT', 'AEROUSDT', 'ACXUSDT', 'ORCAUSDT', 'MOVEUSDT', 'RAYSOLUSDT', 'VIRTUALUSDT', 'SPXUSDT', 'KOMAUSDT', 'MEUSDT', 'ABCCCUSDT', 'AVAUSDT', 'DEGOUSDT', 'VELODROMEUSDT', 'MOCAUSDT', 'VANAUSDT', 'PENGUUSDT', 'LUMIAUSDT', 'USUALUSDT', 'KMNOUSDT', 'CGPTUSDT', 'AIXBTUSDT', 'FARTCOINUSDT', 'HIVEUSDT', 'DEXEUSDT', 'PHAUSDT', 'DFUSDT', 'GRIFFAINUSDT', 'AI16ZUSDT', 'ZEREBROUSDT', 'BIOUSDT', 'COOKIEUSDT', 'ALCHUSDT', 'SWARMSUSDT', 'SONICUSDT', 'DUSDT', 'PROMUSDT', 'SUSDT', 'ARCUSDT', 'AVAAIUSDT', 'TRUMPUSDT', 'MELANIAUSDT', 'VTHOUSDT', 'ANIMEUSDT', 'PIPPINUSDT', 'VINEUSDT', 'VVVUSDT', 'BERAUSDT', 'TSTUSDT', 'LAYERUSDT', 'HEIUSDT', 'B3USDT', 'IPUSDT', 'GPSUSDT', 'SHELLUSDT', 'KAITOUSDT', 'REDUSDT', 'VICUSDT', 'BMTUSDT', 'MUBARAKUSDT', 'BROCCOLI714USDT', 'BROCCOLIF3BUSDT', 'BANANAS31USDT', 'SIRENUSDT', 'BNXUSDT', 'BRUSDT', 'PLUMEUSDT', 'PAXGUSDT', 'WALUSDT', 'FUNUSDT', 'MLNUSDT', 'ATHUSDT', 'BABYUSDT', 'FORTHUSDT', 'PROMPTUSDT', 'XCNUSDT', 'PUMPUSDT', 'STOUSDT', 'FHEUSDT', 'INITUSDT', 'BANKUSDT', 'EPTUSDT', 'DEEPUSDT', 'HYPERUSDT', 'MEMEFIUSDT', 'FISUSDT', 'JSTUSDT', 'SIGNUSDT', 'PUNDIXUSDT', 'AIOTUSDT', 'DOLOUSDT', 'HAEDALUSDT', 'SXTUSDT', 'ALPINEUSDT', 'ASRUSDT', 'B2USDT', 'MILKUSDT', 'SYRUPUSDT', 'OBOLUSDT', 'OGUSDT', 'ZKJUSDT', 'SKYAIUSDT', 'NXPCUSDT', 'AGTUSDT', 'BUSDT', 'AUSDT', 'MERLUSDT', 'HYPEUSDT', 'BDXNUSDT', 'PUFFERUSDT', 'PORT3USDT', '1000000BOBUSDT', 'SKATEUSDT', 'TAIKOUSDT', 'SQDUSDT']
# symbols = ['BTCUSDT', 'ETHUSDT', 'BCHUSDT', 'XRPUSDT', 'LTCUSDT', 'TRXUSDT', 'ETCUSDT', 'LINKUSDT', 'XLMUSDT', 'ADAUSDT', 'DASHUSDT', 'ZECUSDT', 'XTZUSDT', 'BNBUSDT', 'ATOMUSDT', 'ONTUSDT', 'IOTAUSDT', 'BATUSDT', 'VETUSDT', 'NEOUSDT', 'QTUMUSDT', 'IOSTUSDT', 'THETAUSDT', 'ALGOUSDT', 'ZILUSDT', 'KNCUSDT', 'ZRXUSDT', 'COMPUSDT', 'OMGUSDT', 'DOGEUSDT', 'SXPUSDT', 'KAVAUSDT', 'BANDUSDT', 'RLCUSDT', 'MKRUSDT', 'SNXUSDT', 'DOTUSDT', 'DEFIUSDT', 'YFIUSDT', 'BALUSDT', 'CRVUSDT', 'TRBUSDT', 'RUNEUSDT', 'SUSHIUSDT', 'EGLDUSDT', 'SOLUSDT', 'ICXUSDT', 'STORJUSDT', 'UNIUSDT', 'AVAXUSDT', 'ENJUSDT', 'FLMUSDT', 'KSMUSDT', 'NEARUSDT', 'AAVEUSDT', 'FILUSDT', 'RSRUSDT', 'LRCUSDT', 'BELUSDT', 'AXSUSDT', 'ALPHAUSDT', 'ZENUSDT', 'SKLUSDT', 'GRTUSDT', 'BNTUSDT', '1INCHUSDT', 'CHZUSDT', 'SANDUSDT', 'ANKRUSDT', 'LITUSDT', 'RVNUSDT', 'SFPUSDT', 'XEMUSDT', 'COTIUSDT', 'CHRUSDT', 'MANAUSDT', 'ALICEUSDT', 'HBARUSDT', 'ONEUSDT', 'LINAUSDT', 'STMXUSDT', 'DENTUSDT', 'CELRUSDT', 'HOTUSDT', 'MTLUSDT', 'OGNUSDT', 'NKNUSDT', '1000SHIBUSDT', 'BAKEUSDT', 'GTCUSDT', 'BTCDOMUSDT', 'MASKUSDT', 'IOTXUSDT', 'C98USDT', 'ATAUSDT', 'DYDXUSDT', '1000XECUSDT', 'GALAUSDT', 'CELOUSDT', 'ARUSDT', 'ARPAUSDT', 'CTSIUSDT', 'LPTUSDT', 'ENSUSDT', 'PEOPLEUSDT', 'ROSEUSDT', 'DUSKUSDT', 'FLOWUSDT', 'IMXUSDT', 'API3USDT', 'GMTUSDT', 'APEUSDT', 'WOOUSDT', 'JASMYUSDT', 'OPUSDT', 'XMRUSDT', 'INJUSDT', 'STGUSDT', 'SPELLUSDT', '1000LUNCUSDT', 'LUNA2USDT', 'LDOUSDT', 'APTUSDT', 'QNTUSDT', 'FXSUSDT', 'HOOKUSDT', 'MAGICUSDT', 'TUSDT', 'HIGHUSDT', 'MINAUSDT', 'ASTRUSDT', 'PHBUSDT', 'FETUSDT', 'GMXUSDT', 'CFXUSDT', 'STXUSDT', 'ACHUSDT', 'SSVUSDT', 'CKBUSDT', 'PERPUSDT', 'LQTYUSDT', 'ARBUSDT', 'IDUSDT', 'JOEUSDT', 'LEVERUSDT', 'TRUUSDT', 'RDNTUSDT', 'HFTUSDT', 'XVSUSDT', 'BLURUSDT', 'EDUUSDT', '1000PEPEUSDT', '1000FLOKIUSDT', 'UMAUSDT', 'COMBOUSDT', 'SUIUSDT', 'NMRUSDT', 'MAVUSDT', 'XVGUSDT', 'WLDUSDT', 'PENDLEUSDT', 'ARKMUSDT', 'AGLDUSDT', 'YGGUSDT', 'DODOXUSDT', 'OXTUSDT', 'SEIUSDT', 'CYBERUSDT', 'HIFIUSDT', 'ARKUSDT', 'BICOUSDT', 'LOOMUSDT', 'BIGTIMEUSDT', 'BONDUSDT', 'ORBSUSDT', 'WAXPUSDT', 'BSVUSDT', 'RIFUSDT', 'POLYXUSDT', 'GASUSDT', 'POWRUSDT', 'TIAUSDT', 'CAKEUSDT', 'MEMEUSDT', 'TOKENUSDT', 'ORDIUSDT', 'STEEMUSDT', 'ILVUSDT', 'NTRNUSDT', 'KASUSDT', 'BEAMXUSDT', '1000BONKUSDT', 'PYTHUSDT', 'SUPERUSDT', 'USTCUSDT', 'ONGUSDT', 'ETHWUSDT', 'JTOUSDT', '1000SATSUSDT', 'AUCTIONUSDT', '1000RATSUSDT', 'ACEUSDT', 'MOVRUSDT', 'TWTUSDT', 'NFPUSDT', 'AIUSDT', 'XAIUSDT', 'WIFUSDT', 'MANTAUSDT', 'ONDOUSDT', 'LSKUSDT', 'ALTUSDT', 'JUPUSDT', 'ZETAUSDT', 'RONINUSDT', 'DYMUSDT', 'OMUSDT', 'PIXELUSDT', 'STRKUSDT', 'GLMUSDT', 'PORTALUSDT', 'TONUSDT', 'AXLUSDT', 'MYROUSDT', 'METISUSDT', 'AEVOUSDT', 'VANRYUSDT', 'BOMEUSDT', 'ETHFIUSDT', 'ENAUSDT', 'WUSDT', 'TNSRUSDT', 'SAGAUSDT', 'TAOUSDT', 'OMNIUSDT', 'REZUSDT', 'BBUSDT', 'NOTUSDT', 'TURBOUSDT', 'IOUSDT', 'ZKUSDT', 'MEWUSDT', 'LISTAUSDT', 'ZROUSDT', 'RENDERUSDT', 'BANANAUSDT', 'RAREUSDT', 'GUSDT', 'SYNUSDT', 'SYSUSDT', 'VOXELUSDT', 'BRETTUSDT', 'ALPACAUSDT', 'POPCATUSDT', 'SUNUSDT', 'VIDTUSDT', 'NULSUSDT', 'DOGSUSDT', 'MBOXUSDT', 'CHESSUSDT', 'FLUXUSDT', 'BSWUSDT', 'QUICKUSDT', 'NEIROETHUSDT', 'RPLUSDT', 'POLUSDT', 'UXLINKUSDT', 'NEIROUSDT', '1MBABYDOGEUSDT', 'KDAUSDT', 'FIDAUSDT', 'FIOUSDT', 'CATIUSDT', 'GHSTUSDT', 'LOKAUSDT', 'HMSTRUSDT', 'REIUSDT', 'COSUSDT', 'EIGENUSDT', 'DIAUSDT', '1000CATUSDT', 'SCRUSDT', 'GOATUSDT', 'MOODENGUSDT', 'SAFEUSDT', 'SANTOSUSDT', 'TROYUSDT', 'PONKEUSDT', 'CETUSUSDT', 'COWUSDT', '1000000MOGUSDT', 'GRASSUSDT', 'DRIFTUSDT', 'SWELLUSDT', 'PNUTUSDT', 'ACTUSDT', 'HIPPOUSDT', '1000XUSDT', 'DEGENUSDT', 'BANUSDT', 'AKTUSDT', 'SLERFUSDT', 'SCRTUSDT', '1000WHYUSDT', '1000CHEEMSUSDT', 'THEUSDT', 'MORPHOUSDT', 'CHILLGUYUSDT', 'KAIAUSDT', 'AEROUSDT', 'ACXUSDT', 'ORCAUSDT', 'MOVEUSDT', 'RAYSOLUSDT', 'VIRTUALUSDT', 'SPXUSDT', 'KOMAUSDT', 'MEUSDT', 'ABCCCUSDT', 'AVAUSDT', 'DEGOUSDT', 'VELODROMEUSDT', 'MOCAUSDT', 'VANAUSDT', 'PENGUUSDT', 'LUMIAUSDT', 'USUALUSDT', 'KMNOUSDT', 'CGPTUSDT', 'AIXBTUSDT', 'FARTCOINUSDT', 'HIVEUSDT', 'DEXEUSDT', 'PHAUSDT', 'DFUSDT', 'GRIFFAINUSDT', 'AI16ZUSDT', 'ZEREBROUSDT', 'BIOUSDT', 'COOKIEUSDT', 'ALCHUSDT', 'SWARMSUSDT', 'SONICUSDT', 'DUSDT', 'PROMUSDT', 'SUSDT', 'ARCUSDT', 'AVAAIUSDT', 'TRUMPUSDT', 'MELANIAUSDT', 'VTHOUSDT', 'ANIMEUSDT', 'PIPPINUSDT', 'VINEUSDT', 'VVVUSDT', 'BERAUSDT', 'TSTUSDT', 'LAYERUSDT', 'HEIUSDT', 'B3USDT', 'IPUSDT', 'GPSUSDT', 'SHELLUSDT', 'KAITOUSDT', 'REDUSDT', 'VICUSDT', 'BMTUSDT', 'MUBARAKUSDT', 'BROCCOLI714USDT', 'BROCCOLIF3BUSDT', 'BANANAS31USDT', 'SIRENUSDT', 'BNXUSDT', 'BRUSDT', 'PLUMEUSDT', 'PAXGUSDT', 'WALUSDT', 'FUNUSDT', 'MLNUSDT', 'ATHUSDT', 'BABYUSDT', 'FORTHUSDT', 'PROMPTUSDT', 'XCNUSDT', 'PUMPUSDT', 'STOUSDT', 'FHEUSDT', 'INITUSDT', 'BANKUSDT', 'EPTUSDT', 'DEEPUSDT', 'HYPERUSDT', 'MEMEFIUSDT', 'FISUSDT', 'JSTUSDT', 'SIGNUSDT', 'PUNDIXUSDT', 'AIOTUSDT', 'DOLOUSDT', 'HAEDALUSDT', 'SXTUSDT', 'ALPINEUSDT', 'ASRUSDT', 'B2USDT', 'MILKUSDT', 'SYRUPUSDT', 'OBOLUSDT', 'OGUSDT', 'ZKJUSDT', 'SKYAIUSDT', 'NXPCUSDT', 'AGTUSDT', 'BUSDT', 'AUSDT', 'MERLUSDT', 'HYPEUSDT', 'BDXNUSDT', 'PUFFERUSDT', 'PORT3USDT', '1000000BOBUSDT', 'SKATEUSDT', 'TAIKOUSDT', 'SQDUSDT']






import datetime
from datetime import datetime, timedelta
import pytz
from datetime import timezone
import asyncio
import logging
from tqdm import tqdm
from datetime import datetime, timedelta, timezone
import configparser
import db
import binance
import os
import csv
import joblib
import numpy as np
import talib
import os
import pandas as pd


# Настройка логирования
logging.basicConfig(level=logging.INFO)

# Глобальные переменные
conf: db.ConfigInfo
client: binance.Futures


# === Глобальные переменные ===

MODEL_DIR = "./models"  # Путь, где лежат модели .joblib

indicator_list = [
    'EMA10', 'EMA20', 'EMA30', 'EMA50', 'EMA100',
    'SMA50', 'SMA100', 'SMA200', 'VWMA', 'Ichimoku',
    'RSI', 'Stoch.RSI', 'CCI', 'ADX', 'MACD', 'BBP', 'UO',
    'EMA200', 'SMA10', 'SMA20', 'SMA30', 'HullMA', 'STOCH.K', 'AO', 'Mom', 'W%R'
]




indicator_signal_map = {
    'SELL': 0,
    'NEUTRAL': 1,
    'BUY': 2
}

final_signal_map = {
    'STRONG_SELL': 0,
    'SELL': 1,
    'NEUTRAL': 2,
    'BUY': 3,
    'STRONG_BUY': 4
}

# === Основная функция ===

def safe_predict(model, X):
    """
    Обертка для predict, чтобы подать X с именами признаков, если модель их требует.
    """
    if hasattr(model, 'feature_names_in_'):
        feature_names = model.feature_names_in_
        X_df = pd.DataFrame(X, columns=feature_names)
        return model.predict(X_df)
    else:
        return model.predict(X)




# def get_technical_rating(klines):
#     df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'] + ['_'] * 6).astype(float)
#
#     close, high, low, volume = df['close'].values, df['high'].values, df['low'].values, df['volume'].values
#
#     signal_vector = {}
#
#     # === TA-Lib индикаторы ===
#     try:
#         signal_vector['EMA10'] = talib.EMA(close, 10)[-1]
#         signal_vector['EMA20'] = talib.EMA(close, 20)[-1]
#         signal_vector['EMA30'] = talib.EMA(close, 30)[-1]
#         signal_vector['EMA50'] = talib.EMA(close, 50)[-1]
#         signal_vector['EMA100'] = talib.EMA(close, 100)[-1]
#         signal_vector['SMA50'] = talib.SMA(close, 50)[-1]
#         signal_vector['SMA100'] = talib.SMA(close, 100)[-1]
#         signal_vector['SMA200'] = talib.SMA(close, 200)[-1]
#         signal_vector['RSI'] = talib.RSI(close, 14)[-1]
#         signal_vector['Stoch.RSI'] = talib.STOCHRSI(close, 14)[0][-1]
#         signal_vector['CCI'] = talib.CCI(high, low, close, 14)[-1]
#         signal_vector['ADX'] = talib.ADX(high, low, close, 14)[-1]
#         signal_vector['MACD'] = talib.MACD(close, 12, 26, 9)[0][-1]
#         upper, middle, lower = talib.BBANDS(close, 20)
#         signal_vector['BBP'] = (close[-1] - lower[-1]) / (upper[-1] - lower[-1] + 1e-9)
#         signal_vector['UO'] = talib.ULTOSC(high, low, close)[-1]
#     except Exception as e:
#         print(f"Ошибка TA-Lib: {e}")
#
#     # === Кастомные индикаторы ===
#     try:
#         signal_vector['EMA200'] = talib.EMA(close, 200)[-1]
#         signal_vector['SMA10'] = talib.SMA(close, 10)[-1]
#         signal_vector['SMA20'] = talib.SMA(close, 20)[-1]
#         signal_vector['SMA30'] = talib.SMA(close, 30)[-1]
#
#         wma_half = talib.WMA(close, 9)
#         wma_full = talib.WMA(close, 18)
#         hull = 2 * wma_half - wma_full
#         signal_vector['HullMA'] = talib.WMA(hull, 6)[-1]
#
#         signal_vector['STOCH.K'] = talib.STOCH(high, low, close)[0][-1]
#         median_price = (high + low) / 2
#         ao = talib.SMA(median_price, 5) - talib.SMA(median_price, 34)
#         signal_vector['AO'] = ao[-1]
#         signal_vector['Mom'] = talib.MOM(close, 10)[-1]
#         signal_vector['W%R'] = talib.WILLR(high, low, close, 14)[-1]
#
#         # VWMA
#         vwma = pd.Series(close) * pd.Series(volume)
#         signal_vector['VWMA'] = (vwma.rolling(20).sum() / pd.Series(volume).rolling(20).sum()).iloc[-1]
#
#         # Ichimoku Base Line
#         high_series = pd.Series(high)
#         low_series = pd.Series(low)
#         signal_vector['Ichimoku'] = ((high_series.rolling(26).max() + low_series.rolling(26).min()) / 2).iloc[-1]
#
#         # print('SIGNAL VECTOR', signal_vector)
#     except Exception as e:
#         print(f"Ошибка кастом индикаторов: {e}")
#
#     # === Предсказания индикаторных моделей ===
#     indicator_signals = {}
#
#     for ind in indicator_list:
#         try:
#             model_path = os.path.join(MODEL_DIR, f'{ind}_signal_model.joblib')
#
#             if not os.path.exists(model_path):
#                 continue
#
#             model = joblib.load(model_path)
#
#             # Формируем X как при обучении
#             if ind == 'Mom':
#                 X_ind = np.array([[signal_vector['Mom'], 0]])  # Нет лагов — diff=0
#             elif ind == 'W%R':
#                 try:
#                     wpr_series = talib.WILLR(high, low, close, timeperiod=14)
#                     wpr_recent = pd.Series(wpr_series[-5:]).fillna(0)
#                     wpr_mean = wpr_recent.mean()
#                     wpr_std = wpr_recent.std()
#                 except:
#                     wpr_mean = 0
#                     wpr_std = 0
#                 X_ind = np.array([[signal_vector['W%R'], wpr_mean, wpr_std]])
#             else:
#                 X_ind = np.array([[signal_vector[ind]]])
#
#             pred_signal_num = safe_predict(model, X_ind)[0]
#
#             # Декодируем предсказанный int обратно в строку (SELL / NEUTRAL / BUY)
#             decoded_signal = None
#             for k, v in indicator_signal_map.items():
#                 if v == pred_signal_num:
#                     decoded_signal = k
#                     break
#             indicator_signals[ind] = decoded_signal if decoded_signal else 'NEUTRAL'
#             # print('indicator signals', indicator_signals)
#
#         except Exception as e:
#             print(f"Ошибка предсказания для {ind}: {e}")
#
#     # === Финальная модель ===
#     try:
#         print('indicator signals', indicator_signals)
#         final_model_path = os.path.join(MODEL_DIR, 'final_signal_model.joblib')
#
#         if not os.path.exists(final_model_path):
#             print("Финальная модель не найдена!")
#             return 'HOLD'
#
#         final_model = joblib.load(final_model_path)
#
#         # Составляем финальный X (список из числовых значений сигналов по каждому индикатору)
#         X_final = []
#         for ind in indicator_list:
#             sig = indicator_signals.get(ind, 'NEUTRAL')
#             X_final.append(indicator_signal_map.get(sig, 1))  # 1 = NEUTRAL по дефолту
#
#         final_pred_num = safe_predict(final_model, [X_final])[0]
#
#         # Декодируем итоговый сигнал из числа в строку (STRONG_SELL / SELL / NEUTRAL / BUY / STRONG_BUY)
#         final_signal = None
#         for k, v in final_signal_map.items():
#             if v == final_pred_num:
#                 final_signal = k
#                 break
#
#         return final_signal if final_signal else 'HOLD'
#
#     except Exception as e:
#         print(f"Ошибка финальной модели: {e}")
#         return 'HOLD'



def get_technical_rating(klines):
    df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'] + ['_'] * 6).astype(float)

    close, high, low, volume = df['close'].values, df['high'].values, df['low'].values, df['volume'].values

    signal_series = {}
    indicator_signals = {}

    try:
        # TA-Lib индикаторы — сохраняем Series
        signal_series.update({
            'EMA10': talib.EMA(close, 10),
            'EMA20': talib.EMA(close, 20),
            'EMA30': talib.EMA(close, 30),
            'EMA50': talib.EMA(close, 50),
            'EMA100': talib.EMA(close, 100),
            'SMA50': talib.SMA(close, 50),
            'SMA100': talib.SMA(close, 100),
            'SMA200': talib.SMA(close, 200),
            'RSI': talib.RSI(close, 14),
            'Stoch.RSI': talib.STOCHRSI(close, 14)[0],
            'CCI': talib.CCI(high, low, close, 14),
            'ADX': talib.ADX(high, low, close, 14),
            'MACD': talib.MACD(close, 12, 26, 9)[0],
            'BBP': (close - talib.BBANDS(close, 20)[2]) / (talib.BBANDS(close, 20)[0] - talib.BBANDS(close, 20)[2] + 1e-9),
            'UO': talib.ULTOSC(high, low, close),
        })
    except Exception as e:
        print(f"Ошибка TA-Lib: {e}")

    try:
        wma_half = talib.WMA(close, 9)
        wma_full = talib.WMA(close, 18)
        hull = 2 * wma_half - wma_full
        median_price = (high + low) / 2

        signal_series.update({
            'EMA200': talib.EMA(close, 200),
            'SMA10': talib.SMA(close, 10),
            'SMA20': talib.SMA(close, 20),
            'SMA30': talib.SMA(close, 30),
            'HullMA': talib.WMA(hull, 6),
            'STOCH.K': talib.STOCH(high, low, close)[0],
            'AO': talib.SMA(median_price, 5) - talib.SMA(median_price, 34),
            'Mom': talib.MOM(close, 10),
            'W%R': talib.WILLR(high, low, close, 14),
            'VWMA': (pd.Series(close) * pd.Series(volume)).rolling(20).sum() / pd.Series(volume).rolling(20).sum(),
            'Ichimoku': ((pd.Series(high).rolling(26).max() + pd.Series(low).rolling(26).min()) / 2)
        })
    except Exception as e:
        print(f"Ошибка кастом индикаторов: {e}")

    # Предсказания по каждому индикатору
    for ind in indicator_list:
        try:
            model_path = os.path.join(MODEL_DIR, f'{ind}_signal_model.joblib')
            if not os.path.exists(model_path):
                continue

            model = joblib.load(model_path)
            features = list(model.feature_names_in_)

            series = pd.Series(signal_series.get(ind)).dropna()
            if len(series) < 2:
                continue

            if ind == 'W%R':
                wpr_series = series
                if len(wpr_series) < 6:
                    continue
                X_ind = pd.DataFrame([{
                    'W%R_manual_value': wpr_series.iloc[-1],
                    'wpr_mean_5': wpr_series.iloc[-6:-1].mean(),
                    'wpr_std_5': wpr_series.iloc[-6:-1].std()
                }])
            else:
                curr = series.iloc[-1]
                prev = series.iloc[-2]
                X_ind = pd.DataFrame([{
                    f'{ind}_manual_value': curr,
                    f'{ind}_lag1': prev,
                    f'{ind}_diff1': curr - prev
                }])

            pred_signal_num = model.predict(X_ind)[0]
            decoded_signal = next(k for k, v in indicator_signal_map.items() if v == pred_signal_num)
            indicator_signals[ind] = decoded_signal

        except Exception as e:
            print(f"Ошибка предсказания {ind}: {e}")

    print('INDICATOR SIGNALS', indicator_signals)

    # Финальная модель
    try:
        final_model_path = os.path.join(MODEL_DIR, 'final_signal_model.joblib')
        if not os.path.exists(final_model_path):
            print("Финальная модель не найдена!")
            return 'HOLD'

        final_model = joblib.load(final_model_path)

        X_final = [indicator_signal_map.get(indicator_signals.get(ind, 'NEUTRAL'), 1) for ind in indicator_list]
        X_final_df = pd.DataFrame([X_final], columns=final_model.feature_names_in_)

        final_pred_num = final_model.predict(X_final_df)[0]
        final_signal = next(k for k, v in final_signal_map.items() if v == final_pred_num)
        return final_signal

    except Exception as e:
        print(f"Ошибка финальной модели: {e}")
        return 'HOLD'




def save_signals_to_csv(filename, data_rows):
    file_exists = os.path.isfile(filename)

    with open(filename, mode='a', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=['symbol', 'interval', 'signal', 'entry_price', 'utc_time'])

        if not file_exists:
            writer.writeheader()

        writer.writerows(data_rows)



symbols = ['BTCUSDT', 'ETHUSDT', ]

interval = '4h'


# Настройка логирования
logging.basicConfig(level=logging.INFO)

# Глобальные переменные
conf: db.ConfigInfo
client: binance.Futures
config = configparser.ConfigParser()


# symbols = ['BTCUSDT', 'ETHUSDT']

interval_minutes = 4 * 60  # для 4h

# Временной диапазон
start_date = datetime(2025, 2, 22, tzinfo=pytz.UTC)
# end_date = datetime(2025, 6, 15, tzinfo=pytz.UTC)

end_date = datetime(2025, 3, 5, tzinfo=pytz.UTC)

# Настройки лимитов
BATCH_SIZE = 20                # Кол-во символов в одном батче
BATCH_DELAY = 10              # Задержка между батчами (сек)

config = configparser.ConfigParser()


# async def process_symbol(symbol, conf, client):
#     current_time = start_date
#     total_steps = int(((end_date - start_date).total_seconds()) // (interval_minutes * 60))
#     signals = []
#
#     window_size = 150  # кол-во свечей в окне
#
#     with tqdm(total=total_steps, desc=f"{symbol} {interval}") as pbar:
#         while current_time <= end_date:
#             try:
#                 # Таймстемпы для скользящего окна
#                 end_ts = int(current_time.timestamp() * 1000)
#                 start_time = current_time - timedelta(minutes=interval_minutes * window_size)
#                 start_ts = int(start_time.timestamp() * 1000)
#
#                 klines = await client.klines(
#                     symbol,
#                     interval=interval,
#                     startTime=start_ts,
#                     endTime=end_ts,
#                     limit=window_size
#                 )
#
#                 if not klines or len(klines) < window_size:
#                     logging.warning(f"[{symbol} @ {current_time}] Недостаточно данных: {len(klines)} < {window_size}")
#                     current_time += timedelta(minutes=interval_minutes)
#                     pbar.update(1)
#                     await asyncio.sleep(1)
#                     continue
#
#                 last_kline_time = datetime.fromtimestamp(klines[-1][0] / 1000, tz=timezone.utc)
#                 if last_kline_time != current_time:
#                     logging.warning(f"[{symbol} @ {current_time}] Последняя свеча не совпадает с текущим временем. "
#                                     f"Kline[-1] = {last_kline_time}")
#                     current_time += timedelta(minutes=interval_minutes)
#                     pbar.update(1)
#                     await asyncio.sleep(1)
#                     continue
#
#                 rating = get_technical_rating(klines)
#                 last_close = float(klines[-1][4])
#                 utc_time = last_kline_time
#
#                 # if symbol == 'BTCUSDT' or rating in ['STRONG_SELL', 'STRONG_BUY']:
#                 #     signals.append({
#                 #         'symbol': symbol,
#                 #         'interval': interval,
#                 #         'signal': rating,
#                 #         'entry_price': last_close,
#                 #         'utc_time': utc_time.strftime('%Y-%m-%d %H:%M:%S')
#                 #     })
#
#                 signals.append({
#                     'symbol': symbol,
#                     'interval': interval,
#                     'signal': rating,
#                     'entry_price': last_close,
#                     'utc_time': utc_time.strftime('%Y-%m-%d %H:%M:%S')
#                 })
#
#             except Exception as e:
#                 logging.error(f"[{symbol} @ {current_time}] Ошибка: {e}")
#
#             # Сдвиг времени на следующий бар
#             current_time += timedelta(minutes=interval_minutes)
#             pbar.update(1)
#
#     return signals


async def process_symbol(symbol, conf, client):
    current_time = start_date
    total_steps = int(((end_date - start_date).total_seconds()) // (interval_minutes * 60))
    signals = []

    window_size = 150  # Длина скользящего окна

    with tqdm(total=total_steps, desc=f"{symbol} {interval}") as pbar:
        while current_time <= end_date:
            try:
                # Скользящее окно: от (current_time - 150 баров) до current_time
                end_time = current_time
                start_time = end_time - timedelta(minutes=interval_minutes * window_size)
                start_ts = int(start_time.timestamp() * 1000)

                klines = await client.klines(
                    symbol,
                    interval=interval,
                    startTime=start_ts,
                    limit=window_size
                )

                if not klines or len(klines) < window_size:
                    logging.warning(f"[{symbol} @ {current_time}] Недостаточно данных: {len(klines)} < {window_size}")
                    current_time += timedelta(minutes=interval_minutes)
                    pbar.update(1)
                    await asyncio.sleep(0.1)
                    continue

                # Проверяем, что последняя свеча совпадает с текущим временем - 1 бар
                last_kline_time = datetime.fromtimestamp(klines[-1][0] / 1000, tz=timezone.utc)
                expected_last_time = current_time - timedelta(minutes=interval_minutes)

                if last_kline_time != expected_last_time:
                    logging.warning(f"[{symbol} @ {current_time}] Последняя свеча не совпадает с ожидаемой. "
                                    f"Kline[-1] = {last_kline_time}, ожидалось {expected_last_time}")
                    current_time += timedelta(minutes=interval_minutes)
                    pbar.update(1)
                    await asyncio.sleep(0.1)
                    continue

                # Получаем сигнал на этом отрезке
                rating = get_technical_rating(klines)
                last_close = float(klines[-1][4])
                utc_time = last_kline_time

                signals.append({
                    'symbol': symbol,
                    'interval': interval,
                    'signal': rating,
                    'entry_price': last_close,
                    'utc_time': utc_time.strftime('%Y-%m-%d %H:%M:%S')
                })

            except Exception as e:
                logging.error(f"[{symbol} @ {current_time}] Ошибка: {e}")

            current_time += timedelta(minutes=interval_minutes)
            pbar.update(1)

    return signals




async def process_batch(batch_symbols, conf, client):
    tasks = [process_symbol(symbol, conf, client) for symbol in batch_symbols]
    results = await asyncio.gather(*tasks, return_exceptions=True)

    # Обработка исключений внутри gather
    all_signals = []
    for result in results:
        if isinstance(result, Exception):
            logging.error(f"Ошибка в таске: {result}")
        else:
            all_signals.extend(result)
    return all_signals


async def main():
    global start_date, end_date, interval, interval_minutes, symbols

    config.read('config.ini')
    session = await db.connect(config['DB']['host'], int(config['DB']['port']), config['DB']['user'],
                               config['DB']['password'], config['DB']['db'])
    conf = await db.load_config()
    client = binance.Futures(
        conf.api_key, conf.api_secret,
        asynced=True,
        testnet=config.getboolean('BOT', 'testnet')
    )


    all_signals = []

    # Разбиваем на батчи
    for i in range(0, len(symbols), BATCH_SIZE):
        batch_symbols = symbols[i:i+BATCH_SIZE]
        logging.info(f"Запуск батча: {batch_symbols}")

        batch_signals = await process_batch(batch_symbols, conf, client)
        all_signals.extend(batch_signals)

        # Задержка между батчами
        if i + BATCH_SIZE < len(symbols):
            await asyncio.sleep(BATCH_DELAY)

    # Сохраняем результат
    save_signals_to_csv('manual_signals.csv', all_signals)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
